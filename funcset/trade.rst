.. _wsapi_general:

交易及账户信息反馈
==================================================
为实现交易功能, 通常需要协议提供这些功能

* 终端登录鉴权 - req_login
* 终端发出下单指令 - insert_order
* 终端发出撤单指令 - cancel_order
* 向终端同步账户信息变动 - rtn_data


概念定义和账户结构
--------------------------------------------------
为避免歧义, 在后续文档中将使用这些特定单词描述:

* USER: 一个独立的用户. 
* ACCOUNT: 一个USER可以拥有多个ACCOUNT, 
* POSITION: 一个USER可以拥有多个POSITION
* ORDER:
* UNIT: 


委托单的单号
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* 每个委托单都必须有一个单号, 单号可以是不超过128个字节长的任意字符, 数字和点号(.)组合. 
* 单号由发出下单指令的终端负责设定, 它必须保证, 对于同一个USER, 每个单号都是不重复的.
* 单号中的点号(.) 作为 unit 分隔符使用 (详见下文 UNIT机制 说明)


委托单状态
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
任何一个委托单的状态只会是以下两种之一:

* FINISHED: 已经可以确定, 这个委托单以后不会再产生任何新的成交
* ALIVE: 除上一种情况外的其它任何情况, 委托单状态都标记为 ALIVE, 即这个委托单还有可能产生新的成交


UNIT机制
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
例如, 单号为  AA.BB.CC.D 的委托单, 同时属于以下几个unit
* root unit, unit_id == ""
* AA
* AA.BB
* AA.BB.CC




用户内存结构
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



终端登录鉴权
--------------------------------------------------
我们使用 aid = "req_login" 的包作为登录请求包. 此包的结构由具体的实现定义. 以 XXX 项目为例, req_login 包结构如下:

.. code-block:: javascript
   :caption: req_login
   
  {
    "aid": req_login,        //注册FemasOpen服务器
    "broker_id": "8000",                //broker_id
    "trade_servers:[
        "tcp://201.203.10.22:12345",    //交易服务器地址端口
        ...
    ],
    "query_servers:[
        "tcp://201.203.10.22",          //查询服务器地址端口
        ...
    ],
    "user_id": "user1",             //登录用户名
    "password": "abcd",             //登录密码
  }


交易指令
--------------------------------------------------

下单
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
终端通过发送 insert_order 包实现下单
  
.. code-block:: javascript

  {
    "aid": "insert_order",          //必填, 下单请求
    "order_id": "SomeStrategy.Instance1.0001",  //必填, 委托单号, 需确保在一个账号中不重复, 限长512字节
    "user_id": "user1",             //可选, 与登录用户名一致, 在只登录了一个用户的情况下,此字段可省略
    "exchange_id": "SHFE",          //必填, 下单到哪个交易所
    "instrument_id": "cu1803",      //必填, 下单合约代码
    "direction": "BUY",             //必填, 下单买卖方向
    "offset": "OPEN",               //可选, 下单开平方向, 当指令相关对象不支持开平机制(例如股票)时可不填写此字段
    "volume": 1,                    //必填, 下单手数
    "price_type": "LIMIT",          //必填, 报单价格类型
    "limit_price": 30502,           //当 price_type == LIMIT 时需要填写此字段, 报单价格 
  }

撤单
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
终端通过发送 cancel_order 包实现撤单

.. code-block:: javascript

  {
    "aid": "cancel_order",          //必填, 撤单请求
    "order_id": "0001",             //必填, 委托单的order_id
  }


信息反馈
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
终端通过接收 rtn_order 包来更新本地的


从主进程接收业务数据
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
当从主进程向扩展进程发送数据时, 与其它很多协议不同, 天勤的通讯协议并不会按照 "类别" 或 "请求", 将数据分解为多个包发送.
相反, 天勤只使用一种包 :ref:`rtn_data`, 来将主程序内存中的全部数据 (实时行情, 历史行情, 交易数据等) 送往扩展进程.
为减少数据量, 主程序每次发送 :ref:`rtn_data` 时, 通常只包含与前次相比有差异的数据. ( **注意: 协议并不承诺无差异的数据一定不会发送** )

基于这一协议, 我们强烈建议 **扩展进程应设法维护一个完整的业务信息存储区** (在内存,数据库或文件中), 并在每次收到 :ref:`rtn_data` 时更新此存储区中的内容.
扩展进程中的业务代码, 应从这一存储区中获取业务信息, 而 **不要直接让业务逻辑处理接收到的每个:ref:`rtn_data`包**


协议实现
-----------------------------------
目前已经有部分支持 DIFF 协议的项目提供了对交易功能的支持, 包括:

* `Open Trade Gateway <https://github.com/shinnytech/open-trade-gateway>`_ : 一个开源的交易网关, 支持CTP等交易系统到 DIFF 协议的转换
* `Shinny Future Android <https://github.com/shinnytech/shinny-futures-android>`_ : 一个开源的 android 平台期货行情交易终端
* `天勤衍生品研究终端 <http://www.tq18.cn>`_ : 一套免费的PC行情交易终端, 支持以 DIFF 协议进行扩展开发.
* `Tianqin Python Sdk <https://github.com/tianqin18/tqsdk-python>`_ : 一套开源的 python 框架, 
